
✔ Set up devops scripts so we can interact with linux servers @done(Tuesday, 2018/11/13 10:36 pm)
✔ Create basic project structure and get on GitHub @done(Tuesday, 2018/11/13 10:36 pm)
✔ Test provisioning a server with JRE @done(Tuesday, 2018/11/13 10:37 pm)
✔ Create a script that allows us to run PNServer using the command line @started(Saturday, 2018/11/17 04:52 am) @done(Saturday, 2018/11/17 08:48 am)
✔ Custom command line arguments to PNServer and PNClient @done(Saturday, 2018/11/17 08:48 am)
✔ Test connecting PNClient to PNServer @done(Saturday, 2018/11/17 08:48 am)
✔ Write utility methods for logging @done(Saturday, 2018/11/17 08:49 am)
✘ Write admin commands API so we can write to stdin @cancelled(Tuesday, 2018/11/27 05:13 pm)
   This isn't necessary right now, and it doesn't have to ever be necessary. Game servers are supposed to have extremely short lifespans. They're supposed to literally last for one game session.
✔ Distinguish connection release in terms of "abortive" and "orderly". Implement both forms of connection release. @done(Thursday, 2018/11/22 01:01 pm)
   https://docs.oracle.com/javase/8/docs/technotes/guides/net/articles/connection_release.html

   Situation:
      One connection between two machines. Machine A (MA) and Machine B (MB).
      FIN denotes a message that indicates orderly release. Short for "Finish".
      RST denotes a message that indicates abortive release. Short for "Reset".

   Orderly connection release:
      The connection is open on both ends
      State:
         MA-OUT   ON
         MA-IN    ON
         MB-OUT   ON
         MB-IN    ON

         Both ends of the connection are aware that all streams are  ON

         ✘ Test @cancelled(Thursday, 2018/11/22 01:02 pm)

      MA decides to stop sending data and sends FIN to MB
      State:
         MA-OUT   OFF
         MA-IN    ON
         MB-OUT   ON
         MB-IN    ON

         MA is aware MA-OUT is   OFF

         ✘ Test @cancelled(Thursday, 2018/11/22 01:02 pm)

      MB receives this message in the form of further byte-reads returning -1
      State: 
         MA-OUT   OFF
         MA-IN    ON
         MB-OUT   ON
         MB-IN    ON

         MA+MB are aware that MA-OUT is   OFF
         
         ✘ Test @cancelled(Thursday, 2018/11/22 01:02 pm)

      MB then acknowledges MA's FIN message by sending FIN back to MA.
      State: 
         MA-OUT   OFF
         MA-IN    ON
         MB-OUT   OFF
         MB-IN    ON
         
         MA+MB are aware that MA-OUT is   OFF
         MB is aware that     MB-OUT is   OFF
         
         ✘ Test @cancelled(Thursday, 2018/11/22 01:02 pm)
         
      MA receives MB's FIN in the form of further byte-reads returning -1
      State: 
         MA-OUT   OFF
         MA-IN    ON
         MB-OUT   OFF
         MB-IN    ON
         
         MA+MB are aware that MA-OUT is   OFF
         MB+MA is aware that  MB-OUT is   OFF
         
         ✘ Test @cancelled(Thursday, 2018/11/22 01:02 pm)
      
      MA closes the socket. MA stops managing the connection.
      State: 
         MA-OUT   OFF
         MA-IN    OFF
         MB-OUT   OFF
         MB-IN    ON
         
         MA+MB are aware that MA-OUT is   OFF
         MB+MA is aware that  MB-OUT is   OFF
         MA is aware that     MA-IN is    OFF
         
         ✘ Test @cancelled(Thursday, 2018/11/22 01:02 pm)
      
      MB receives an RST because MA closed the socket
      State:
         MA-OUT   OFF
         MA-IN    OFF
         MB-OUT   OFF
         MB-IN    OFF (Receiving RST automatically closes both IN and OUT)

         MA+MB are aware that MA-OUT is   OFF
         MB+MA is aware that  MB-OUT is   OFF
         MA+MB are aware that MA-IN is    OFF
         
         ✘ Test @cancelled(Thursday, 2018/11/22 01:02 pm)

      Out of precaution, MB also closes the socket. MB stops managing its end of the connection.
      State:
         MA-OUT   OFF
         MA-IN    OFF
         MB-OUT   OFF
         MB-IN    OFF

         MA+MB are aware that MA-OUT is   OFF
         MB+MA is aware that  MB-OUT is   OFF
         MA+MB are aware that MA-IN is    OFF
         
         ✘ Test @cancelled(Thursday, 2018/11/22 01:02 pm)
      
      ✘ Implementation @cancelled(Thursday, 2018/11/22 01:02 pm)

   Abortive connection release:
      The connection is open on both ends
      State:
         MA-OUT   ON
         MA-IN    ON
         MB-OUT   ON
         MB-IN    ON

         Both ends of the connection are aware that all streams are  ON
         
         ✘ Test @cancelled(Thursday, 2018/11/22 01:02 pm)

      MA closes the socket and sends RST to MB. MA stops managing its end of the connection.
      State:
         MA-OUT   OFF
         MA-IN    OFF
         MB-OUT   ON
         MB-IN    ON

         MA is aware that MA-OUT is OFF
         MA is aware that MA-IN is  OFF
         
         ✘ Test @cancelled(Thursday, 2018/11/22 01:02 pm)

      MB receives RST from MA because MA closed the socket
      State:
         MA-OUT   OFF
         MA-IN    OFF
         MB-OUT   OFF (Receiving RST automatically closes both IN and OUT)
         MB-IN    OFF (Receiving RST automatically closes both IN and OUT)

         MA+MB is aware that MA-OUT is OFF
         MA+MB is aware that MA-IN is  OFF
         MB is aware that MB-OUT is    OFF
         MB is aware that MB-IN is     OFF
         
         ✘ Test @cancelled(Thursday, 2018/11/22 01:02 pm)

      Out of precaution, MB also closes the socket. MB stops managing its end of the connection.
      State:
         MA-OUT   OFF
         MA-IN    OFF
         MB-OUT   OFF
         MB-IN    OFF

         MA+MB is aware that MA-OUT is OFF
         MA+MB is aware that MA-IN is  OFF
         MB is aware that MB-OUT is    OFF
         MB is aware that MB-IN is     OFF
         
         ✘ Test @cancelled(Thursday, 2018/11/22 01:02 pm)
      
      ✘ Implementation @cancelled(Thursday, 2018/11/22 01:02 pm)

      UPDATE [2018/11/22 at 13:02 ET]:
         As I began implementing Orderly connection release and Abortive connection release via the "TCP half-close" method, I realized that this is the wrong technical direction for PlexNet. Given that the servers are entirely authoritative, we don't need to use the half-close method. I chose instead to go with the method where we consume all input data before closing the socket. See the "consume" implementation in PNInputStreamReader.
         ✔ Implementation @done(Thursday, 2018/11/22 01:04 pm)

✔ Packets @done(Tuesday, 2018/11/27 05:08 pm)

Accept Policy [2018/11/27 at 17:43 ET]:
   An Accept Policy would be useful to have in the case where we have some underlying requirements the client must undergo before being fully accepted by the Server.
   Technically any connection can be accepted at the TCP level, but we can abstract on top of that and say something like "NO more connections after we have accepted 3 clients", or "All clients must send this secret key".

   ☐ Create a base, step-appendable `PNPolicy` in `pn.policy`.
   ☐ Create a base `PNAcceptPolicy` in 
      ☐ Set up base-necessities like succeeding SessionID authentication
      ☐ Make the Accept Policy appendable so lib clients can easily create their own Accept Policies.
         ☐ Require that the base-policy be used in some manner, SessionIDs are necessary at PN's low-level.
         
   ☐ Create an Accept Policy that requires the client / server secret keys to match
      Failure to enforce this policy should constitute an IP ban for malicious activity. Since we don't support IP bans
      yet, we can just immediately reject the client for "unauthorized access"
   ☐ Create an Accept Policy that requires the client / server version keys to match
      Failure to enforce this policy should result in the client being told they need to update their game.

Client Session [2018/11/27 at 17:10 ET]:
   'Client Session' is an idea I've been thinking about for a few days now. I think we need high-level, overridable, relational object that relates a client to their TCP connection. The idea I have right now is that this is where lib clients would be able to "easily" interact with their PlexNet configuration. It's possible that we will create a low-level composite version of this object that would be an anonymous "Session" object. That means ClientSession and ServerSession could extend Session. For now they will be totally separate implementations.

   Requirements & Design:
      Composition relationship with PNClient
      PNClient owns PNClientSession (PNClientSession is responsible for nulling its reference to PNClient on cleanup)
      Thread safety managed by PNClient without any synchronized tags in the PNClientSession code (so lib users don't have to deal with that)
      Authenticates a client per-session
      Handler for receiving packets
      API for sending packets (should also make it possible for the client to NOT have to handle the flushLock in PNAsyncBufferedOutputStream)
      PNServer generates a SessionID for the PNClientSession as part of the base "Accept Policy" on PNClient
      PNServer will immediately reject a client that fails the Accept Policy

   ☐ Create an Abstract class `PNClientSession` which requires a unique Session ID
      ☐ Create static inner class `SessionId` and override hash/equals/toString
      ☐ 

Server Session TIMESTAMP:

UDP TIMESTAMP:
   ☐ TODO
